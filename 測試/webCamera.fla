import com.adobe.images.JPGEncoder;
import com.adobe.images.PNGEncoder; 


var vid:Video; 
var cam:Camera = Camera.getCamera(); 
cam.setMode(400,450,15) // 設置相機在長，寬，偵


// 顯示文本信息
var tf:TextField = new TextField(); 
tf.x = 480; // 文本顯示在起始位置
tf.autoSize = TextFieldAutoSize.LEFT; 
addChild(tf); 


if (cam != null) { 
cam.addEventListener(StatusEvent.STATUS, statusHandler); 
vid = new Video(400,450); 
vid.attachCamera(cam);
// 旋轉２７０度　（因為我的設備上攝像頭向左轉了９０度，所以需要下邊在方法）
centerRotate(vid, 270);
} 


function statusHandler(event:StatusEvent):void { 
    if (!cam.muted)  { 
        vid.width = cam.width; 
        vid.height = cam.height;
        addChild(vid); 
    } 
    cam.removeEventListener(StatusEvent.STATUS, statusHandler); 
} 








        
/* 一個測試方法，可以用JS調用的 */
ExternalInterface.addCallback("testAS",testFunc);
function testFunc(txt:String):String{
    tf.appendText("2222:::"+txt+"\n"); 
    ExternalInterface.call("saveBrushCardInfo","");
    return "SUCCESS";
}

// 獲得照片信息（該方法被ＪＳ調用）
ExternalInterface.addCallback("getImageAS",getImage);
function getImage(url:String):void{
    // 拍照獲得照片byte數組
    var bitmapData:BitmapData = new BitmapData(vid.height, vid.width-55, false, 0xFFCC00);
    bitmapData.draw(vid);
    var bytes:ByteArray = PNGEncoder.encode(bitmapData);

    // 將照片byte發送請求到后台處理
    var req:URLRequest = new URLRequest(url);
    req.data = bytes;
    req.method = URLRequestMethod.POST;
    req.contentType = "application/octet-stream";

    var loader:URLLoader = new URLLoader();
    loader.dataFormat = URLLoaderDataFormat.BINARY; 
    loader.load(req);
//tf.appendText("3333333333333:::"+"\n");
    loader.addEventListener(Event.COMPLETE, completeHandler);

}

// 回調函數，　調用JS方法　saveBrushCardInfo
function completeHandler(evt:Event):void {
    // ExternalInterface.call("asCallJS","I,m AS!");
    ExternalInterface.call("saveBrushCardInfo","");
    //    trace(evt.target.data);
}

/** 
 * 繞中心點旋轉 
 * @param   mc  元件 
 * @param   angle   角度  360  280
 */  
function centerRotate(mc:DisplayObject,angle:Number):void{  
//獲取mc不旋轉時候的尺寸  
var currentRotation:Number = mc.rotation;  
//tf.appendText("currentRotation:::"+currentRotation+"\n"); 
mc.rotation = 0;  
var mcWidth:Number = mc.width;  
var mcHeight:Number = mc.height;  
//mc.rotation = currentRotation;  

//獲取mc當前中心點坐標  
var pointO:Point = mc.localToGlobal(new Point(mcWidth / 2, mcHeight / 2));  
//tf.appendText("pointO:::"+pointO.x +" --- "+pointO.y +"\n"); 
//旋轉mc  
mc.rotation = angle;  

//獲取mc旋轉后中心點坐標  
var pointO2:Point = mc.localToGlobal(new Point( mcWidth/ 2, mcHeight / 2));
//tf.appendText("pointO2:::"+pointO2.x +" --- "+pointO2.y +"\n"); 

//平移到原來中心點O  
var p3:Point = pointO.subtract(pointO2);  // 減去
//tf.appendText("p3:::"+p3.x +" --- "+p3.y +"\n"); 
var matrix:Matrix = mc.transform.matrix;  
matrix.translate(p3.x, 400);

mc.transform.matrix = matrix;  
 
}

// 向左旋轉９０
function scaleLeft(bmp:BitmapData):BitmapData{ 
var m:Matrix = new Matrix(); 
m.rotate(-Math.PI/2); 
m.translate(0,bmp.width); 
var bd:BitmapData = new BitmapData(bmp.height, bmp.width,false); 
bd.draw(bmp,m); 
return bd; 
}